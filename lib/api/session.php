<?php

/******BEGIN LICENSE BLOCK*******
* 
* Common Public Attribution License Version 1.0.
*
* The contents of this file are subject to the Common Public Attribution 
* License Version 1.0 (the "License") you may not use this file except in 
* compliance with the License. You may obtain a copy of the License at
* http://developers.facebook.com/fbopen/cpal.html. The License is based 
* on the Mozilla Public License Version 1.1 but Sections 14 and 15 have 
* been added to cover use of software over a computer network and provide 
* for limited attribution for the Original Developer. In addition, Exhibit A 
* has been modified to be consistent with Exhibit B.
* Software distributed under the License is distributed on an "AS IS" basis, 
* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License 
* for the specific language governing rights and limitations under the License.
* The Original Code is Facebook Open Platform.
* The Original Developer is the Initial Developer.
* The Initial Developer of the Original Code is Facebook, Inc.  All portions 
* of the code written by Facebook, Inc are 
* Copyright 2006-2008 Facebook, Inc. All Rights Reserved.
*
*
********END LICENSE BLOCK*********/


// Facebook Copyright 2006 - 2008

include_once $_SERVER['PHP_ROOT'].'/lib/api/auth.php';
include_once $_SERVER['PHP_ROOT'].'/lib/api/errorcodes.php';
include_once $_SERVER['PHP_ROOT'].'/lib/api/application.php';

define('INFINITE_SESSION_TIMEOUT', 0);
define('API_VERSION_10', '1.0');

/**
 * lib/api/session
 *
 * Functions for tracking API sessions
 *
 **/

/**
 * Given an API version passed in from the outside, resolve it to an
 * actual API version.
 *
 */
// FBOPEN:NOTE - Facebook API version 0.9  is not supported here.
function api_resolve_version($version) {

  // Adding your own versions starts here.
  $valid_versions = array( API_VERSION_10 => 1);
  if (isset($valid_versions[$version])) {
    return $version;
  } else {
    return API_VERSION_10; // Redundant, but the default.
  }
}

/**
 * Extracts the user id from the session key (as generated by
 * api_session_generate_key).
 *
 * @return an unmangled user id for the session.
 */
 // FBOPEN:NOTE - this constant 25 depends on the length of your hashing.
function api_session_extract_uid($session_key) {
  return substr($session_key, 25);
}


/**
 * Returns whether the given session has timed out.
 * @param string $session_key the session to check
 * @param int    $app_id      the application id
 * @return bool true if the session has timed out, false otherwise
 */
function api_is_session_timed_out($session_key, $app_id)
{
  $user_id = api_session_extract_uid($session_key, $app_id);
  if (!$user_id) {
    // if the session key is bad, return that the session has expired
    return true;
  }
  if (!($session_info = api_session_get_info($session_key, $app_id))) {
    error_log("Cannot get session info for session key: $session_key, app: $app_id");
    return true;
  }

  return (($session_info['session_timeout'] != INFINITE_SESSION_TIMEOUT) &&
          ($session_info['key_create_time'] + $session_info['session_timeout'] <= time()));
}

/**
 * Checks if a session is still valid (ie has not timed out).
 *
 * @return API_EC_SUCCESS on success or another API_EC_* on error
 */
function api_session_check_valid($session_key, $app_id) {

  // make sure we are passed a well-formed session key before trying
  // it.  attempts to match v0.9 and v1 session keys.
  if (preg_match('/^[0-9a-f]+-[.\w-]+$/', $session_key)) {
    $info = api_session_get_info($session_key, $app_id);
  } else {
    $info = null;
  }

  if ($info) {
    $app_info = application_get_info($app_id);
    if (!$app_info) {
      error_log('api_session_check_valid: invalid app id?');
      return API_EC_UNKNOWN;
    }
    if (!api_is_session_timed_out($session_key, $app_id)) {
      if ($app_info['desktop']) {
        // desktop apps have a timeout based on the time since the last
        // request instead of time since session created.
        $info['key_create_time'] = time();

        // FBOPEN: NOTE - Here, you may wish to set this new session in
        // memcache or some more temporary storage, as these turn over
        // quite a bit.
      }
      return API_EC_SUCCESS;
    } else {
      return API_EC_PARAM_SESSION_KEY;
    }
  } else {
    return API_EC_PARAM_SESSION_KEY;
  }
}

function api_session_get_info($session_key, $app_id) {
  global $data_conn;
  $uid = api_session_extract_uid($session_key);

  if (!$uid) {
    // we got passed a bad session key - apps do that sometimes
    return null;
  }

  if ($data_conn) {
    $sql =    'SELECT * FROM session WHERE uid=%d and session_key=%s';
    if ($ret = queryf($data_conn, $sql, $uid, $session_key)) {
      $row =  mysql_fetch_assoc($ret);
      return $row;
    }
  }
  return false;
}


/**
 * Create an auth_token which can later (after the user logs in) be converted
 * into a session.
 *
 * @param string $session_key if not null, also binds the session to the authtoken
 * @return the auth_token, or null on failure
 */
function api_authtoken_create($application_id, $session_key = null) {

  $auth_token = api_generate_rand_key();

  $ret = _api_authtoken_insert($application_id, $auth_token, $session_key, 3600);
  if (!$ret) {
    return null;
  }
  return $auth_token;
}

/**
 * For use as part of the login flow for desktop applications.  Bind a session
 * to an auth_token.  This can fail if the specified auth_token doesn't exist,
 * has expired, or already has a session bound to it.
 *
 * @param string $auth_token as returned by api_authtoken_create
 * @return false on failure, true on success
 */
function api_authtoken_bind($application_id, $auth_token, $session_key) {
  $info = api_authtoken_get_info($application_id, $auth_token, false);
  if (!is_array($info) || (isset($info['session_key']) && $info['session_key'])) {
    // the authtoken either doesn't exist, is expired, or already has a session bound
    return false;
  } else {
    return _api_authtoken_update($application_id, $auth_token, $session_key);
  }
}

/**
 * Get information about the specified auth_token.
 *
 * @param string $auth_token as returned by api_authtoken_create
 * @param bool   $expire     will remove the authtoken from
 * @return an array containing the application_id, auth_token, session_key, and
 *         row_created_time for the auth_token
 */
function api_authtoken_get_info($application_id, $auth_token, $expire=true) {

  $info = _api_dbget_authtoken($application_id, $auth_token);

  // Only expire if we're told to (API: auth.getSession), and it exists in db,
  // and is bound to a session key (desktop apps may not be)
  if ($expire && is_array($info) && isset($info['session_key'])) {
    // FBOPEN: NOTE: If this token is not bound to a session key, and is set to expire,
    // expire it here.
    _api_authtoken_expire($application_id, $auth_token);
  }
  return $info;
}

/**
 * Expire an auth_token by deleting it from the DB.
 *
 * @param int $application_id object ID of application
 * @param string $auth_token Hex string of auth_token to expire
 * @return true on successful find in database, otherwise false
 */
function _api_authtoken_expire($application_id, $auth_token) {
  global $data_conn;

  // FBOPEN: NOTE - expire your token by deleting it from your data store.

  if ($data_conn) {
    $sql =    'DELETE FROM auth_token WHERE application_id=%d and auth_token=%s';
    if ($ret = queryf($data_conn, $sql, $application_id, $auth_token )) {
        return true;
    }
  }
  return false;
}

/**
 * Get auth_token from database.  If found to be expired, expire auth_token
 *
 * @param int $application_id object ID of application
 * @param string $auth_token Hex string of auth_token to expire
 * @return info array (currently containing just 'session_key' key) if object
 *  present in database, else false
 */
function _api_dbget_authtoken($application_id, $auth_token) {

  global $data_conn;
  if ($data_conn) {
    $sql =    'SELECT * FROM auth_token WHERE application_id=%d and auth_token=%s';
    if ($ret = queryf($data_conn, $sql, $application_id, $auth_token )) {
      $token = mysql_fetch_assoc($ret);
      if ($token['expire_time'] <= time()) {
        _api_authtoken_expire($application_id, $auth_token);
        return false;
      }
      return array('session_key' => $token['session_key']);
    }
  }
  return false;
}


/**
 * Insert auth_token into database.
 *
 * @param int    $application_id object ID of application
 * @param string $auth_token     Hex string of auth_token
 * @param string $session_key    session key value to bind with, or null
 * @param int    $expire_incr    Number of seconds before the token becomes invalid.
 * @return true if successfully set in db, false otherwise
 */
function _api_authtoken_insert($application_id, $auth_token, $session_key, $expire_incr) {
  global $data_conn;

  if ($data_conn) {
    $expire_time = time() + $expire_incr;
    $sql =    'REPLACE INTO auth_token ' .
      '(application_id, auth_token, session_key, expire_time)' .
      'VALUES (%d, %s, %s, %d)';

    if ($ret = queryf($data_conn, $sql,
                      $application_id, $auth_token, $session_key, $expire_time)) {
        return true;
    }
  }
  return false;
}

/**
 * Binds an auth_token with a session_key in the the database.  Only
 * called for desktop apps.
 *
 * @param int    $application_id object ID of application
 * @param string $auth_token     Hex string of auth_token
 * @param string $session_key    session_key with which to bind
 * @return true if successfully updated in db, false otherwise
 */
function _api_authtoken_update($application_id, $auth_token, $session_key) {

  global $data_conn;
  if ($data_conn) {
    // The only case where the given (app_id, auth_token) pair doesn't
    // exist in the DB is when two login requests with the same app_id
    // and auth_token (which apps shouldn't be doing anyway) arrive
    // simultaneously, *and* a getSession call comes in before one of
    // the login attempts completes.  This is extremely rare (and we
    // probably want to know about it), so a login failure is okay.

    $sql = 'UPDATE auth_token SET session_key=%s WHERE application_id=%s AND auth_token=%s';
    if (!($ret = queryf($data_conn, $sql, $session_key, $application_id, $auth_token))) {
      error_log("Failed to bind session_key: $session_key with auth_token : $auth_token for app"
          . " $application");
      return null;
    }
    return true;
  }
  return null;
}

// FBOPEN:NOTE - Include your own session management here.
function api_get_valid_session_key($user, $app_id) {
  global $DEMO_SESSION_KEY;
  return $DEMO_SESSION_KEY;
}
